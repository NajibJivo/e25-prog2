# Spring Data JPA Integration

In this guide, we will use Spring Data JPA to interact with a relational database. Spring Data JPA simplifies the data access layer by providing a repository abstraction over JPA. JPA is a set of specifications for managing relational data in Java applications. 

Since JPA is just a specification, we need an implementation. The most commonly used implementation is Hibernate, which is included by default when you add the `Spring Data JPA` dependency (see [Spring Data JPA Reference](https://spring.io/projects/spring-data-jpa) for more).

## Prerequisites
- To follow along, you need a Spring Boot project set up with:
    - `Spring Web`
    - `Spring Data JPA` 
    - `H2 Database` (for testing purposes)
    - `MySQL Driver` (for MySQL access)


## Configuration for database access

To configure database access, we need to set up the `application.properties` file located in `src/main/resources/` package.

``` properties
spring.application.name=demo

# H2 Configuration
spring.datasource.url=jdbc:h2:mem:testdb
spring.datasource.driver-class-name=org.h2.Driver
spring.datasource.username=sa
spring.datasource.password=
spring.h2.console.enabled=true
spring.h2.console.path=/h2-console

# MySQL configuration - REPLACE WITH OWN DB DETAILS
#spring.datasource.url=jdbc:mysql://localhost:3306/your_database_name
#spring.datasource.username=your_username
#spring.datasource.password=your_password
#spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.jpa.hibernate.ddl-auto=create

# Show SQL statements in the console
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true
```

This configuration uses an in-memory H2 database for testing purposes. You can switch to MySQL by uncommenting the MySQL configuration section and providing your database details.

The `spring.jpa.hibernate.ddl-auto=create` property ensures that the database schema is recreated at startup (see [Spring docs](https://docs.spring.io/spring-boot/how-to/data-initialization.html#howto.data-initialization.using-hibernate) for more details). The supported values are `none`, `validate`, `update`, `create`, and `create-drop`.

The `show-sql` property enables logging of SQL statements generated by Hibernate. When set to `true`, it helps in debugging and understanding the queries being executed.


## Creating JPA Entities
JPA entities are Java classes that represent database tables. Each entity class is annotated with `@Entity`, and each field in the class corresponds to a column in the table.

Here is a simple example of a JPA entity class:

```java
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;

@Entity
@Table(name = "users")
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;
    private String email;

    // Getters and Setters
}
```

The `@Id` annotation specifies the primary key of the entity, and `@GeneratedValue` indicates that the ID should be generated automatically in the database. Since `user` is a reserved keyword in some databases, we use the `@Table` annotation to specify a different table name, otherwise it would default to the class name.

## Database access with Spring Data JPA Repositories
Spring Data JPA provides a repository abstraction that simplifies data access. You can create a repository interface for your entity by extending one of the Spring Data repository interfaces, such as `JpaRepository`.

```java
import org.springframework.data.jpa.repository.JpaRepository;

public interface UserRepository extends JpaRepository<User, Long> {
    // Custom query methods (if needed) can be defined here
}
```
This interface provides CRUD operations and pagination support for the `User` entity. You can also define custom query methods by following Spring Data JPA's method naming conventions.

Notice the notation of `Long` in `JpaRepository<User, Long>`, which indicates the type of the primary key of the entity.

## Accessing the database
You can use the repository in your service or controller classes to perform database operations. Here is an example of a simple controller class that uses the `UserRepository`:

```java
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/users")
public class UserController {

    private final UserRepository userRepository;

    public UserController(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    @GetMapping
    public ResponseEntity<List<User>> getAllUsers() {
        List<User> users = userRepository.findAll();
        return ResponseEntity.ok(users);
    }

    @PostMapping
    public ResponseEntity<User> createUser(@RequestBody User user) {
        User savedUser = userRepository.save(user);
        return ResponseEntity.created(URI.create("/api/users/" + savedUser.getId())).body(savedUser);
    }

    @GetMapping("/{id}")
    public ResponseEntity<User> getUserById(@PathVariable Long id) {
        Optional<User> userOptional = userRepository.findById(id)
        if (userOptional.isPresent()) {
            return ResponseEntity.ok(userOptional.get());
        }
        return ResponseEntity.notFound().build();
    }

    @PutMapping("/{id}")
    public ResponseEntity<User> updateUser(@PathVariable Long id, @RequestBody User user) {
        if (!userRepository.existsById(id)) {
            return ResponseEntity.notFound().build();
        }
        user.setId(id); // Ensure the user ID is set
        User updatedUser = userRepository.save(user);
        return ResponseEntity.ok(updatedUser);
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteUser(@PathVariable Long id) {
        if (!userRepository.existsById(id)) {
            return ResponseEntity.notFound().build();
        }
        userRepository.deleteById(id);
        return ResponseEntity.noContent().build();
    }
}
```

In this example, the `UserController` class provides RESTful endpoints for managing users. It uses the `UserRepository` to perform CRUD operations on the `User` entity.

The different respository methods used are:
- `findAll()`: Retrieves all users from the database.
- `save(User user)`: Saves a new user or updates an existing user in the database (based on whether the user ID is null or not).
- `findById(Long id)`: Retrieves a user by its ID.
- `existsById(Long id)`: Checks if a user exists by its ID.
- `deleteById(Long id)`: Deletes a user by its ID.


## Adding derived query methods
Spring Data JPA allows you to define custom query methods in your repository interfaces by following a naming convention. For example, if you want to find users by that contains a specific name, you can add the following method to the `UserRepository` interface:

```java
import java.util.List;
public interface UserRepository extends JpaRepository<User, Long> {
    List<User> findByNameContainingIgnoreCase(String name);
}
```

You can then use this method in the controller with query parameters:

```java
@GetMapping
public ResponseEntity<List<User>> getAllUsers(@RequestParam(required = false) String name) {
    if (name != null && !name.isEmpty()) {
        return ResponseEntity.ok(userRepository.findByNameContainingIgnoreCase(name));
    }
    return ResponseEntity.ok(userRepository.findAll());
}
```

## Adding sample data at startup
You can use a `CommandLineRunner` interface to insert sample data into the database when the application starts. Here is an example of how to do this:

```java
import org.springframework.boot.CommandLineRunner;
import org.springframework.stereotype.Component;

import java.util.Arrays;

@Component
public class InitData implements CommandLineRunner {

    private final UserRepository userRepository;

    public InitData(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    @Override
    public void run(String... args) throws Exception {
        User user1 = new User("Alice", "alice@example.com");
        User user2 = new User("Bob", "bob@example.com");
        userRepository.saveAll(Arrays.asList(user1, user2));
    }
}
```

When the application starts, the `run` method will be executed, and the sample users will be saved to the database. Using this approach ensures that the Spring context (including the database connection) is fully initialized before the data is inserted.

## Enumerations in JPA entities
You can use Java enums in your JPA entities to represent a fixed set of constants. To store enum values in the database, you can use the `@Enumerated` annotation.

Here is an example of how to use enums in a JPA entity:

```java
import javax.persistence.*;

@Entity
@Table(name = "users")
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    private String email;

    @Enumerated(EnumType.STRING)
    private UserRole role;

    // Getters and setters
}

public enum UserRole {
    USER,
    ADMIN
}
```

This will store the enum values as strings in the database. The use of Enums ensures type safety and makes your code more readable. But be cautious when changing enum values, as it may lead to data inconsistencies in the database.

## Changing database field properties
You can customize the properties of database fields using the `@Column` annotation. This allows you to specify attributes such as length, nullability, and uniqueness.

```java
import javax.persistence.*;

@Entity
@Table(name = "users")
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(length = 100, nullable = false)
    private String name;

    @Column(length = 100, nullable = false, unique = true)
    private String email;

    @Enumerated(EnumType.STRING)
    private UserRole role;

    // Getters and setters
}
```

This example sets the maximum length of the `name` and `email` fields to 100 characters, makes them non-nullable, and ensures that the `email` field is unique.


## Testing Derived Query Methods and Repositories
You can write **integration tests** to verify that your JPA entities and repositories are working correctly. Spring Boot provides support for testing with an in-memory database (by default). Here is an example of a test class that tests the `UserRepository`:

```java
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;

import java.util.List;

import static org.junit.jupiter.api.Assertions.*;

@DataJpaTest
class CourseRepositoryTest {

    @Autowired
    CourseRepository courseRepository;
    
    @Test
    void whenFindByNameContainingIgnoreCase_thenReturnCourses() {
        // Arrange
        Course course1 = new Course(null,"Java Basics", "Learn the basics of Java", true, null);
        Course course2 = new Course(null, "Spring Boot", "Introduction to Spring Boot", true, null);
        Course course3 = new Course(null,"Building Java Applications", "Advanced Java topics", true, null);
        courseRepository.saveAll(List.of(course1, course2, course3));
        // Act
        var result = courseRepository.findByNameContainingIgnoreCase("java");

        // Assert
        assertEquals(2, result.size());
        assertEquals("Java Basics", result.getFirst().getName());
        assertEquals("Learn the basics of Java", result.getFirst().getDescription());
        assertEquals("Building Java Applications", result.getLast().getName());
        assertEquals("Advanced Java topics", result.getLast().getDescription());
    }
}
```

> When learning Spring Data JPA, it is a good idea to testing repository methods like this to ensure that your queries are working as expected, especially when we later introduce more complex relationships and queries.


### Verifying database used
You can verify which database is being used in your tests by autowiring the `DataSource` bean and printing its class name. This is only for learning purposes:

```java

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;

import javax.sql.DataSource;

@DataJpaTest
class CourseRepositoryTest {

    @Autowired
    DataSource dataSource;

    @Test
    void testDataSource() throws Exception {
        System.out.println(dataSource.getConnection().getMetaData().
    }
}
```
This will print the database used in the tests ie. `H2`.

## `@Transactional` annotation
The annotation `@Transactional` can be used to manage transactions in your service or repository methods. When a method is annotated with `@Transactional`, Spring will automatically start a transaction when the method is called and commit it when the method completes successfully. If an exception occurs, the transaction will be rolled back.

Here is an example of a simulated rollback scenario:

```java
@Transactional
public User createUser(User user) {
    user.setId(null); // Ensure the ID is null for new entities
    userRepository.save(user);
    throw new RuntimeException("Simulated failure after saving user");
}
```
With the above code, the user will not be saved to the database because the exception will cause the transaction to be rolled back. If we have left out the `@Transactional` annotation, the user would have been saved despite the exception. So adding `@Transactional` is crucial for ensuring that the database remains consistent and that partial changes are not committed.

### When to use `@Transactional`
You typically use `@Transactional` in service layer methods that perform multiple database operations that should be treated as a single unit of work.

Furthermore, `@Transactional` supports dirty checking, which means that if you retrieve an entity from the database, modify its fields, and the entity is still within a transactional context, JPA will automatically detect the changes and update the database when the method completes.

```java
@Transactional
public void updateUserEmail(Long userId, String newEmail) {
    Optional<User> user = userRepository.findById(userId);
    if (user.isPresent()) {
        user.get().setEmail(newEmail);
        // No need to call save() - changes will be automatically persisted
    } else {
        throw new RuntimeException("User not found with id: " + userId);
    }
}
```
