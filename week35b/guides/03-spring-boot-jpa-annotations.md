# Spring Data JPA - fetching strategies and cascading operations

## Introduction to fetching strategies and cascading operations
When we fetch (query the db) an entity with a relationship (like one-to-one), the related entity may not be fetched immediately. This results in an extra query to the database when we try to access the related entity. In large applications this can lead to performance issues. Spring Data JPA provides fetching strategies to optimize data retrieval.

Cascading operations allow us to perform operations (like save, delete) on related entities automatically when we perform the same operation on the parent entity (the one who owns the relationship). This is useful in one-to-one relationships where we want to ensure that when we delete a `Student`, the associated `StudentProfile` is also deleted.

## Specifying Fetching Strategies
In Spring Data JPA, we can specify the fetching strategy using the `fetch` attribute in the `@OneToOne` annotation. The two main strategies are:
- **Eager Fetching**: The related entity is fetched immediately when   the parent entity is fetched.
- **Lazy Fetching**: The related entity is fetched only when it is accessed for the first time.

The default fetching strategy for `@OneToOne` is eager fetching. However, in many cases, lazy fetching is preferred to avoid unnecessary data retrieval, especially when the related entity is not always needed.

To specify that we want to use lazy fetching, we can modify the `@OneToOne` annotation like this:
```java
@OneToOne(fetch = FetchType.LAZY)
private StudentProfile profile;
```

This way, when we fetch a `Student`, the `StudentProfile` will not be fetched immediately. Instead, it will be fetched only when we access the `profile` field.

## Handling Cascading Operations
Cascading operations allow us to propagate operations from the parent entity to the related entity. For example, if we want to delete a `Student` and also delete the associated `StudentProfile`, we can use the `cascade` attribute in the `@OneToOne` annotation.
```java
@OneToOne(cascade = CascadeType.ALL)
private StudentProfile profile;
```
This means that any operation (like save, delete) performed on the `Student` entity will also be performed on the `StudentProfile` entity. The `CascadeType.ALL` option means that all operations (persist, merge, remove, refresh, detach) will be cascaded to the `StudentProfile`.

This in turn mean that we need to change the `InitData` classes `run`-method, since it will be created automatically when we create a `Student` entity:
```java
public void run(String... args) throws Exception {
    Student student = new Student();
    student.setName("OSNB");
    student.setEmail("osnb@example.com");


    StudentProfile profile = new StudentProfile();
    profile.setBio("Ananas pizza is a crime");  
    student.setProfile(profile);

    studentRepository.save(student);
}
```
This way, when we save the `Student`, the `StudentProfile` will also be saved automatically.

There exists several cascade types see fx [cascade types](https://www.baeldung.com/jpa-cascade-types).

## Enabling sql queries in the console
To see the SQL queries generated by Spring Data JPA, we can enable SQL logging in the `application.properties` file:
``` . properties
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true
```

## Exercise
1. Try changing the fetching strategy from eager to lazy and observe the difference in the SQL queries generated when fetching a `Student`.
2. Implement cascading operations by modifying the `@OneToOne` annotation in the `Student` entity to include `cascade = CascadeType.ALL`.
3. Test the cascading operations by deleting a `Student` and checking if the associated `StudentProfile` is also deleted.
